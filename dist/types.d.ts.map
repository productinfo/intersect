{"mappings":"AAEA,6BAA6B;IAC3B,YAAY,EAAE,OAAO,CAAA;IACrB,OAAO,EAAE,MAAM,CAAA;IACf,MAAM,EAAE,MAAM,EAAE,EAAE,CAAA;CACnB,CAAA;AAED;IACE,IAAI,EAAE,MAAM,CAAA;IACZ,IAAI,EAAE,MAAM,CAAA;IACZ,IAAI,EAAE,MAAM,CAAA;IACZ,IAAI,EAAE,MAAM,CAAA;IACZ,KAAK,EAAE,MAAM,CAAA;IACb,MAAM,EAAE,MAAM,CAAA;IACd,QAAQ,CAAC,EAAE,MAAM,CAAA;CAClB;AA6DD;;;;;;GAMG;AACH,gCACE,EAAE,EAAE,MAAM,EAAE,EACZ,EAAE,EAAE,MAAM,EAAE,EACZ,EAAE,EAAE,MAAM,EAAE,EACZ,EAAE,EAAE,MAAM,EAAE,GACX,cAAc,CAkBhB;AAED;;;;;;GAMG;AACH,wCACE,MAAM,EAAE,MAAM,EAAE,EAChB,SAAS,EAAE,MAAM,EAAE,EACnB,EAAE,EAAE,MAAM,EAAE,EACZ,EAAE,EAAE,MAAM,EAAE,GACX,cAAc,CAiBhB;AAED;;;;;;;GAOG;AACH,sCACE,MAAM,EAAE,MAAM,EAAE,EAChB,SAAS,EAAE,MAAM,EAAE,EACnB,KAAK,EAAE,MAAM,EAAE,EACf,IAAI,EAAE,MAAM,EAAE,EACd,QAAQ,SAAI,GACX,cAAc,EAAE,CAElB;AAED;;;;;;;;GAQG;AACH,oCACE,MAAM,EAAE,MAAM,EAAE,EAChB,SAAS,EAAE,MAAM,EAAE,EACnB,MAAM,EAAE,MAAM,EAAE,EAChB,EAAE,EAAE,MAAM,EACV,EAAE,EAAE,MAAM,EACV,QAAQ,EAAE,MAAM,GACf,cAAc,CAIhB;AAED;;;;;;GAMG;AACH,mCACE,MAAM,EAAE,MAAM,EAAE,EAChB,SAAS,EAAE,MAAM,EAAE,EACnB,MAAM,EAAE,QAAQ,EAChB,QAAQ,SAAI,GACX,cAAc,EAAE,CASlB;AAMD;;;;;;GAMG;AACH,wCACE,EAAE,EAAE,MAAM,EAAE,EACZ,EAAE,EAAE,MAAM,EAAE,EACZ,MAAM,EAAE,MAAM,EAAE,EAChB,SAAS,EAAE,MAAM,EAAE,GAClB,cAAc,CAEhB;AAED;;;;;;GAMG;AACH,gDACE,EAAE,EAAE,MAAM,EAAE,EACZ,EAAE,EAAE,MAAM,EAAE,EACZ,EAAE,EAAE,MAAM,EAAE,EACZ,EAAE,EAAE,MAAM,EAAE,GACX,cAAc,CA0BhB;AAED;;;;;;GAMG;AACH,8CACE,EAAE,EAAE,MAAM,EAAE,EACZ,EAAE,EAAE,MAAM,EAAE,EACZ,KAAK,EAAE,MAAM,EAAE,EACf,IAAI,EAAE,MAAM,EAAE,GACb,cAAc,EAAE,CAElB;AAED;;;;;;;;GAQG;AACH,wCACE,EAAE,EAAE,MAAM,EAAE,EACZ,EAAE,EAAE,MAAM,EAAE,EACZ,MAAM,EAAE,MAAM,EAAE,EAChB,MAAM,EAAE,MAAM,EACd,KAAK,EAAE,MAAM,EAAE,EACf,GAAG,EAAE,MAAM,EAAE,GACZ,cAAc,CAuBhB;AAED;;;;;;GAMG;AACH,2CACE,EAAE,EAAE,MAAM,EAAE,EACZ,EAAE,EAAE,MAAM,EAAE,EACZ,CAAC,EAAE,MAAM,EAAE,EACX,CAAC,EAAE,MAAM,GACR,cAAc,CAuChB;AAED;;;;;;;;GAQG;AACH,4CACE,EAAE,EAAE,MAAM,EAAE,EACZ,EAAE,EAAE,MAAM,EAAE,EACZ,MAAM,EAAE,MAAM,EAAE,EAChB,EAAE,EAAE,MAAM,EACV,EAAE,EAAE,MAAM,EACV,QAAQ,SAAI,GACX,cAAc,CA6ChB;AAED;;;;;GAKG;AACH,2CACE,EAAE,EAAE,MAAM,EAAE,EACZ,EAAE,EAAE,MAAM,EAAE,EACZ,MAAM,EAAE,QAAQ,GACf,cAAc,EAAE,CAElB;AAED;;;;;GAKG;AACH,6CACE,EAAE,EAAE,MAAM,EAAE,EACZ,EAAE,EAAE,MAAM,EAAE,EACZ,MAAM,EAAE,MAAM,EAAE,EAAE,GACjB,cAAc,EAAE,CAiBlB;AAMD;;;;;;;GAOG;AACH,sCACE,KAAK,EAAE,MAAM,EAAE,EACf,IAAI,EAAE,MAAM,EAAE,EACd,QAAQ,EAAE,MAAM,EAChB,MAAM,EAAE,MAAM,EAAE,EAChB,SAAS,EAAE,MAAM,EAAE,GAClB,cAAc,EAAE,CAclB;AAED;;;;;;GAMG;AACH,8CACE,KAAK,EAAE,MAAM,EAAE,EACf,IAAI,EAAE,MAAM,EAAE,EACd,EAAE,EAAE,MAAM,EAAE,EACZ,EAAE,EAAE,MAAM,EAAE,GACX,cAAc,EAAE,CAclB;AAED;;;;;;GAMG;AACH,4CACE,MAAM,EAAE,MAAM,EAAE,EAChB,KAAK,EAAE,MAAM,EAAE,EACf,MAAM,EAAE,MAAM,EAAE,EAChB,KAAK,EAAE,MAAM,EAAE,GACd,cAAc,EAAE,CAgBlB;AAED;;;;;;;;GAQG;AACH,sCACE,KAAK,EAAE,MAAM,EAAE,EACf,IAAI,EAAE,MAAM,EAAE,EACd,MAAM,EAAE,MAAM,EAAE,EAChB,MAAM,EAAE,MAAM,EACd,KAAK,EAAE,MAAM,EAAE,EACf,GAAG,EAAE,MAAM,EAAE,GACZ,cAAc,EAAE,CAqBlB;AAED;;;;;;GAMG;AACH,yCACE,KAAK,EAAE,MAAM,EAAE,EACf,IAAI,EAAE,MAAM,EAAE,EACd,CAAC,EAAE,MAAM,EAAE,EACX,CAAC,EAAE,MAAM,GACR,cAAc,EAAE,CAclB;AAED;;;;;;;;GAQG;AACH,0CACE,KAAK,EAAE,MAAM,EAAE,EACf,IAAI,EAAE,MAAM,EAAE,EACd,CAAC,EAAE,MAAM,EAAE,EACX,EAAE,EAAE,MAAM,EACV,EAAE,EAAE,MAAM,EACV,QAAQ,SAAI,GACX,cAAc,EAAE,CAqBlB;AAED;;;;;GAKG;AACH,yCACE,KAAK,EAAE,MAAM,EAAE,EACf,IAAI,EAAE,MAAM,EAAE,EACd,MAAM,EAAE,QAAQ,GACf,cAAc,EAAE,CAGlB;AAED;;;;;GAKG;AACH,2CACE,KAAK,EAAE,MAAM,EAAE,EACf,IAAI,EAAE,MAAM,EAAE,EACd,MAAM,EAAE,MAAM,EAAE,EAAE,GACjB,cAAc,EAAE,CAgBlB;AAMD;;;;;;;;GAQG;AACH,wCACE,MAAM,EAAE,MAAM,EAAE,EAChB,MAAM,EAAE,MAAM,EACd,KAAK,EAAE,MAAM,EAAE,EACf,GAAG,EAAE,MAAM,EAAE,EACb,EAAE,EAAE,MAAM,EAAE,EACZ,EAAE,EAAE,MAAM,EAAE,GACX,cAAc,CAEhB;AAED;;;;;;;;GAQG;AACH,sCACE,MAAM,EAAE,MAAM,EAAE,EAChB,MAAM,EAAE,MAAM,EACd,KAAK,EAAE,MAAM,EAAE,EACf,GAAG,EAAE,MAAM,EAAE,EACb,KAAK,EAAE,MAAM,EAAE,EACf,IAAI,EAAE,MAAM,EAAE,GACb,cAAc,EAAE,CAElB;AAED;;;;;;;GAOG;AACH,mCACE,MAAM,EAAE,MAAM,EAAE,EAChB,MAAM,EAAE,MAAM,EACd,KAAK,EAAE,MAAM,EAAE,EACf,GAAG,EAAE,MAAM,EAAE,EACb,MAAM,EAAE,QAAQ,GACf,cAAc,EAAE,CAUlB;AAMD;;;;;;GAMG;AACH,2CACE,CAAC,EAAE,MAAM,EAAE,EACX,CAAC,EAAE,MAAM,EACT,EAAE,EAAE,MAAM,EAAE,EACZ,EAAE,EAAE,MAAM,EAAE,GACX,cAAc,CAEhB;AAED;;;;;;GAMG;AACH,sCACE,EAAE,EAAE,MAAM,EAAE,EACZ,EAAE,EAAE,MAAM,EACV,EAAE,EAAE,MAAM,EAAE,EACZ,EAAE,EAAE,MAAM,GACT,cAAc,CAgBhB;AAED;;;;;;GAMG;AACH,yCACE,CAAC,EAAE,MAAM,EAAE,EACX,CAAC,EAAE,MAAM,EACT,KAAK,EAAE,MAAM,EAAE,EACf,IAAI,EAAE,MAAM,EAAE,GACb,cAAc,EAAE,CAElB;AAED;;;;;GAKG;AACH,sCACE,CAAC,EAAE,MAAM,EAAE,EACX,CAAC,EAAE,MAAM,EACT,MAAM,EAAE,QAAQ,GACf,cAAc,EAAE,CAGlB;AAMD;;;;;;;;GAQG;AACH,oCACE,MAAM,EAAE,MAAM,EAAE,EAChB,EAAE,EAAE,MAAM,EACV,EAAE,EAAE,MAAM,EACV,QAAQ,EAAE,MAAM,EAChB,KAAK,EAAE,MAAM,EAAE,EACf,SAAS,EAAE,MAAM,EAAE,GAClB,cAAc,CAEhB;AAED;;;;;;;;GAQG;AACH,4CACE,MAAM,EAAE,MAAM,EAAE,EAChB,EAAE,EAAE,MAAM,EACV,EAAE,EAAE,MAAM,EACV,QAAQ,oBAAI,EACZ,EAAE,EAAE,MAAM,EAAE,EACZ,EAAE,EAAE,MAAM,EAAE,GACX,cAAc,CAMhB;AAED;;;;;;;;GAQG;AACH,0CACE,MAAM,EAAE,MAAM,EAAE,EAChB,EAAE,EAAE,MAAM,EACV,EAAE,EAAE,MAAM,EACV,QAAQ,oBAAI,EACZ,KAAK,EAAE,MAAM,EAAE,EACf,IAAI,EAAE,MAAM,EAAE,GACb,cAAc,EAAE,CAMlB;AAED;;;;;;;;;;;GAWG;AACH,wCAEE,GAAG,EAAE,MAAM,EAAE,EAEb,IAAI,EAAE,MAAM,EAEZ,IAAI,EAAE,MAAM,EAEZ,GAAG,EAAE,MAAM,EAEX,GAAG,EAAE,MAAM,EAAE,EAEb,IAAI,EAAE,MAAM,EAEZ,IAAI,EAAE,MAAM,EAEZ,GAAG,EAAE,MAAM,GACV,cAAc,CAGhB;AAED;;;;;;;;GAQG;AACH,uCACE,CAAC,EAAE,MAAM,EAAE,EACX,EAAE,EAAE,MAAM,EACV,EAAE,EAAE,MAAM,EACV,QAAQ,EAAE,MAAM,EAChB,EAAE,EAAE,MAAM,EAAE,EACZ,EAAE,EAAE,MAAM,GACT,cAAc,CAEhB;AAED;;;;;;;GAOG;AACH,uCACE,CAAC,EAAE,MAAM,EAAE,EACX,EAAE,EAAE,MAAM,EACV,EAAE,EAAE,MAAM,EACV,QAAQ,EAAE,MAAM,EAChB,MAAM,EAAE,QAAQ,GACf,cAAc,EAAE,CAUlB;AAED;;;;;GAKG;AACH,mCACE,MAAM,EAAE,QAAQ,EAChB,MAAM,EAAE,MAAM,EAAE,EAChB,SAAS,EAAE,MAAM,EAAE,GAClB,cAAc,EAAE,CAGlB;AAED;;;;;GAKG;AACH,2CACE,MAAM,EAAE,QAAQ,EAChB,EAAE,EAAE,MAAM,EAAE,EACZ,EAAE,EAAE,MAAM,EAAE,GACX,cAAc,EAAE,CAGlB;AAED;;;;;GAKG;AACH,yCACE,MAAM,EAAE,QAAQ,EAChB,KAAK,EAAE,MAAM,EAAE,EACf,IAAI,EAAE,MAAM,EAAE,GACb,cAAc,EAAE,CAGlB;AAED;;;;GAIG;AACH,sCACE,OAAO,EAAE,QAAQ,EACjB,OAAO,EAAE,QAAQ,GAChB,cAAc,EAAE,CAOlB;AAED;;;;;;;GAOG;AACH,mCACE,MAAM,EAAE,QAAQ,EAChB,MAAM,EAAE,MAAM,EAAE,EAChB,MAAM,EAAE,MAAM,EACd,KAAK,EAAE,MAAM,EAAE,EACf,GAAG,EAAE,MAAM,EAAE,GACZ,cAAc,EAAE,CAUlB;AAED;;;;;GAKG;AACH,sCACE,MAAM,EAAE,QAAQ,EAChB,CAAC,EAAE,MAAM,EAAE,EACX,CAAC,EAAE,MAAM,GACR,cAAc,EAAE,CAGlB;AAED;;;;;;;GAOG;AACH,uCACE,MAAM,EAAE,QAAQ,EAChB,CAAC,EAAE,MAAM,EAAE,EACX,EAAE,EAAE,MAAM,EACV,EAAE,EAAE,MAAM,EACV,QAAQ,SAAI,GACX,cAAc,EAAE,CAUlB;AAED;;;;GAIG;AACH,wCACE,MAAM,EAAE,QAAQ,EAChB,MAAM,EAAE,MAAM,EAAE,EAAE,GACjB,cAAc,EAAE,CAElB;AAMD;;;;;GAKG;AACH,6CACE,MAAM,EAAE,MAAM,EAAE,EAAE,EAClB,EAAE,EAAE,MAAM,EAAE,EACZ,EAAE,EAAE,MAAM,EAAE,GACX,cAAc,EAAE,CAElB;AAED;;;;;GAKG;AACH,2CACE,MAAM,EAAE,MAAM,EAAE,EAAE,EAClB,KAAK,EAAE,MAAM,EAAE,EACf,IAAI,EAAE,MAAM,EAAE,GACb,cAAc,EAAE,CAElB;AAED;;;;GAIG;AACH,wCACE,MAAM,EAAE,MAAM,EAAE,EAAE,EAClB,MAAM,EAAE,QAAQ,GACf,cAAc,EAAE,CAMlB","sources":["src/src/index.ts","src/index.ts"],"sourcesContent":[null,"import { Vec } from \"@tldraw/vec\"\n\nexport type TLIntersection = {\n  didIntersect: boolean\n  message: string\n  points: number[][]\n}\n\nexport interface TLBounds {\n  minX: number\n  minY: number\n  maxX: number\n  maxY: number\n  width: number\n  height: number\n  rotation?: number\n}\n\n/**\n * Get an intersection.\n * @param message\n * @param points\n * @internal\n */\nfunction createIntersection(\n  message: string,\n  ...points: number[][]\n): TLIntersection {\n  const didIntersect = points.length > 0\n  return { didIntersect, message, points }\n}\n\n/**\n *\n * @param point\n * @param size\n * @param rotation\n * @internal\n */\nfunction getRectangleSides(\n  point: number[],\n  size: number[],\n  rotation = 0\n): [string, number[][]][] {\n  const center = [point[0] + size[0] / 2, point[1] + size[1] / 2]\n  const tl = Vec.rotWith(point, center, rotation)\n  const tr = Vec.rotWith(Vec.add(point, [size[0], 0]), center, rotation)\n  const br = Vec.rotWith(Vec.add(point, size), center, rotation)\n  const bl = Vec.rotWith(Vec.add(point, [0, size[1]]), center, rotation)\n\n  return [\n    [\"top\", [tl, tr]],\n    [\"right\", [tr, br]],\n    [\"bottom\", [br, bl]],\n    [\"left\", [bl, tl]],\n  ]\n}\n\n/**\n * Get whether angle c lies between angles a and b.\n * @param a\n * @param b\n * @param c\n * @internal\n */\nfunction isAngleBetween(a: number, b: number, c: number): boolean {\n  if (c === a || c === b) return true\n  const PI2 = Math.PI * 2\n  const AB = (b - a + PI2) % PI2\n  const AC = (c - a + PI2) % PI2\n  return AB <= Math.PI !== AC > AB\n}\n\n/* -------------------------------------------------- */\n/*                         Ray                        */\n/* -------------------------------------------------- */\n\n/**\n * Find the intersection between a ray and a ray.\n * @param p0 The first ray's point\n * @param n0 The first ray's direction vector.\n * @param p1 The second ray's point.\n * @param n1 The second ray's direction vector.\n */\nexport function /*#__PURE__*/ intersectRayRay(\n  p0: number[],\n  n0: number[],\n  p1: number[],\n  n1: number[]\n): TLIntersection {\n  const dx = p1[0] - p0[0]\n  const dy = p1[1] - p0[1]\n  const det = n1[0] * n0[1] - n1[1] * n0[0]\n  const u = (dy * n1[0] - dx * n1[1]) / det\n  const v = (dy * n0[0] - dx * n0[1]) / det\n  if (u < 0 || v < 0) return createIntersection(\"miss\")\n\n  const m0 = n0[1] / n0[0]\n  const m1 = n1[1] / n1[0]\n  const b0 = p0[1] - m0 * p0[0]\n  const b1 = p1[1] - m1 * p1[0]\n  const x = (b1 - b0) / (m0 - m1)\n  const y = m0 * x + b0\n\n  return Number.isFinite(x)\n    ? createIntersection(\"intersection\", [x, y])\n    : createIntersection(\"parallel\")\n}\n\n/**\n * Find the intersections between a ray and a line segment.\n * @param origin\n * @param direction\n * @param a1\n * @param a2\n */\nexport function /*#__PURE__*/ intersectRayLineSegment(\n  origin: number[],\n  direction: number[],\n  a1: number[],\n  a2: number[]\n): TLIntersection {\n  const [x, y] = origin\n  const [dx, dy] = direction\n  const [x1, y1] = a1\n  const [x2, y2] = a2\n\n  if (dy / dx !== (y2 - y1) / (x2 - x1)) {\n    const d = dx * (y2 - y1) - dy * (x2 - x1)\n    if (d !== 0) {\n      const r = ((y - y1) * (x2 - x1) - (x - x1) * (y2 - y1)) / d\n      const s = ((y - y1) * dx - (x - x1) * dy) / d\n      if (r >= 0 && s >= 0 && s <= 1) {\n        return createIntersection(\"intersection\", [x + r * dx, y + r * dy])\n      }\n    }\n  }\n  return createIntersection(\"no intersection\")\n}\n\n/**\n * Find the intersections between a ray and a rectangle.\n * @param origin\n * @param direction\n * @param point\n * @param size\n * @param rotation\n */\nexport function /*#__PURE__*/ intersectRayRectangle(\n  origin: number[],\n  direction: number[],\n  point: number[],\n  size: number[],\n  rotation = 0\n): TLIntersection[] {\n  return intersectRectangleRay(point, size, rotation, origin, direction)\n}\n\n/**\n * Find the intersections between a ray and an ellipse.\n * @param origin\n * @param direction\n * @param center\n * @param rx\n * @param ry\n * @param rotation\n */\nexport function /*#__PURE__*/ intersectRayEllipse(\n  origin: number[],\n  direction: number[],\n  center: number[],\n  rx: number,\n  ry: number,\n  rotation: number\n): TLIntersection {\n  const a1 = origin\n  const a2 = Vec.mul(direction, 999999999)\n  return intersectLineSegmentEllipse(a1, a2, center, rx, ry, rotation)\n}\n\n/**\n * Find the intersections between a ray and a bounding box.\n * @param origin\n * @param direction\n * @param bounds\n * @param rotation\n */\nexport function /*#__PURE__*/ intersectRayBounds(\n  origin: number[],\n  direction: number[],\n  bounds: TLBounds,\n  rotation = 0\n): TLIntersection[] {\n  const { minX, minY, width, height } = bounds\n  return intersectRayRectangle(\n    origin,\n    direction,\n    [minX, minY],\n    [width, height],\n    rotation\n  )\n}\n\n/* -------------------------------------------------- */\n/*                    Line Segment                    */\n/* -------------------------------------------------- */\n\n/**\n * Find the intersection between a line segment and a ray.\n * @param a1\n * @param a2\n * @param origin\n * @param direction\n */\nexport function /*#__PURE__*/ intersectLineSegmentRay(\n  a1: number[],\n  a2: number[],\n  origin: number[],\n  direction: number[]\n): TLIntersection {\n  return intersectRayLineSegment(origin, direction, a1, a2)\n}\n\n/**\n * Find the intersection between a line segment and a line segment.\n * @param a1\n * @param a2\n * @param b1\n * @param b2\n */\nexport function /*#__PURE__*/ intersectLineSegmentLineSegment(\n  a1: number[],\n  a2: number[],\n  b1: number[],\n  b2: number[]\n): TLIntersection {\n  const AB = Vec.sub(a1, b1)\n  const BV = Vec.sub(b2, b1)\n  const AV = Vec.sub(a2, a1)\n\n  const ua_t = BV[0] * AB[1] - BV[1] * AB[0]\n  const ub_t = AV[0] * AB[1] - AV[1] * AB[0]\n  const u_b = BV[1] * AV[0] - BV[0] * AV[1]\n\n  if (ua_t === 0 || ub_t === 0) {\n    return createIntersection(\"coincident\")\n  }\n\n  if (u_b === 0) {\n    return createIntersection(\"parallel\")\n  }\n\n  if (u_b !== 0) {\n    const ua = ua_t / u_b\n    const ub = ub_t / u_b\n    if (0 <= ua && ua <= 1 && 0 <= ub && ub <= 1) {\n      return createIntersection(\"intersection\", Vec.add(a1, Vec.mul(AV, ua)))\n    }\n  }\n\n  return createIntersection(\"no intersection\")\n}\n\n/**\n * Find the intersections between a line segment and a rectangle.\n * @param a1\n * @param a2\n * @param point\n * @param size\n */\nexport function /*#__PURE__*/ intersectLineSegmentRectangle(\n  a1: number[],\n  a2: number[],\n  point: number[],\n  size: number[]\n): TLIntersection[] {\n  return intersectRectangleLineSegment(point, size, a1, a2)\n}\n\n/**\n * Find the intersections between a line segment and an arc.\n * @param a1\n * @param a2\n * @param center\n * @param radius\n * @param start\n * @param end\n */\nexport function /*#__PURE__*/ intersectLineSegmentArc(\n  a1: number[],\n  a2: number[],\n  center: number[],\n  radius: number,\n  start: number[],\n  end: number[]\n): TLIntersection {\n  const sa = Vec.angle(center, start)\n  const ea = Vec.angle(center, end)\n  const ellipseTest = intersectEllipseLineSegment(\n    center,\n    radius,\n    radius,\n    0,\n    a1,\n    a2\n  )\n\n  if (!ellipseTest.didIntersect) return createIntersection(\"No intersection\")\n\n  const points = ellipseTest.points.filter((point) =>\n    isAngleBetween(sa, ea, Vec.angle(center, point))\n  )\n\n  if (points.length === 0) {\n    return createIntersection(\"No intersection\")\n  }\n\n  return createIntersection(\"intersection\", ...points)\n}\n\n/**\n * Find the intersections between a line segment and a circle.\n * @param a1\n * @param a2\n * @param c\n * @param r\n */\nexport function /*#__PURE__*/ intersectLineSegmentCircle(\n  a1: number[],\n  a2: number[],\n  c: number[],\n  r: number\n): TLIntersection {\n  const a =\n    (a2[0] - a1[0]) * (a2[0] - a1[0]) + (a2[1] - a1[1]) * (a2[1] - a1[1])\n  const b =\n    2 * ((a2[0] - a1[0]) * (a1[0] - c[0]) + (a2[1] - a1[1]) * (a1[1] - c[1]))\n  const cc =\n    c[0] * c[0] +\n    c[1] * c[1] +\n    a1[0] * a1[0] +\n    a1[1] * a1[1] -\n    2 * (c[0] * a1[0] + c[1] * a1[1]) -\n    r * r\n\n  const deter = b * b - 4 * a * cc\n\n  if (deter < 0) {\n    return createIntersection(\"outside\")\n  }\n\n  if (deter === 0) {\n    return createIntersection(\"tangent\")\n  }\n\n  const e = Math.sqrt(deter)\n  const u1 = (-b + e) / (2 * a)\n  const u2 = (-b - e) / (2 * a)\n  if ((u1 < 0 || u1 > 1) && (u2 < 0 || u2 > 1)) {\n    if ((u1 < 0 && u2 < 0) || (u1 > 1 && u2 > 1)) {\n      return createIntersection(\"outside\")\n    } else {\n      return createIntersection(\"inside\")\n    }\n  }\n\n  const results: number[][] = []\n  if (0 <= u1 && u1 <= 1) results.push(Vec.lrp(a1, a2, u1))\n  if (0 <= u2 && u2 <= 1) results.push(Vec.lrp(a1, a2, u2))\n\n  return createIntersection(\"intersection\", ...results)\n}\n\n/**\n * Find the intersections between a line segment and an ellipse.\n * @param a1\n * @param a2\n * @param center\n * @param rx\n * @param ry\n * @param rotation\n */\nexport function /*#__PURE__*/ intersectLineSegmentEllipse(\n  a1: number[],\n  a2: number[],\n  center: number[],\n  rx: number,\n  ry: number,\n  rotation = 0\n): TLIntersection {\n  // If the ellipse or line segment are empty, return no tValues.\n  if (rx === 0 || ry === 0 || Vec.isEqual(a1, a2)) {\n    return createIntersection(\"No intersection\")\n  }\n\n  // Get the semimajor and semiminor axes.\n  rx = rx < 0 ? rx : -rx\n  ry = ry < 0 ? ry : -ry\n\n  // Rotate points and translate so the ellipse is centered at the origin.\n  a1 = Vec.sub(Vec.rotWith(a1, center, -rotation), center)\n  a2 = Vec.sub(Vec.rotWith(a2, center, -rotation), center)\n\n  // Calculate the quadratic parameters.\n  const diff = Vec.sub(a2, a1)\n\n  const A = (diff[0] * diff[0]) / rx / rx + (diff[1] * diff[1]) / ry / ry\n  const B = (2 * a1[0] * diff[0]) / rx / rx + (2 * a1[1] * diff[1]) / ry / ry\n  const C = (a1[0] * a1[0]) / rx / rx + (a1[1] * a1[1]) / ry / ry - 1\n\n  // Make a list of t values (normalized points on the line where intersections occur).\n  const tValues: number[] = []\n\n  // Calculate the discriminant.\n  const discriminant = B * B - 4 * A * C\n\n  if (discriminant === 0) {\n    // One real solution.\n    tValues.push(-B / 2 / A)\n  } else if (discriminant > 0) {\n    const root = Math.sqrt(discriminant)\n    // Two real solutions.\n    tValues.push((-B + root) / 2 / A)\n    tValues.push((-B - root) / 2 / A)\n  }\n\n  // Filter to only points that are on the segment.\n  // Solve for points, then counter-rotate points.\n  const points = tValues\n    .filter((t) => t >= 0 && t <= 1)\n    .map((t) => Vec.add(center, Vec.add(a1, Vec.mul(Vec.sub(a2, a1), t))))\n    .map((p) => Vec.rotWith(p, center, rotation))\n\n  return createIntersection(\"intersection\", ...points)\n}\n\n/**\n * Find the intersections between a line segment and a bounding box.\n * @param a1\n * @param a2\n * @param bounds\n */\nexport function /*#__PURE__*/ intersectLineSegmentBounds(\n  a1: number[],\n  a2: number[],\n  bounds: TLBounds\n): TLIntersection[] {\n  return intersectBoundsLineSegment(bounds, a1, a2)\n}\n\n/**\n * Find the intersections between a line segment and a polyline.\n * @param a1\n * @param a2\n * @param points\n */\nexport function /*#__PURE__*/ intersectLineSegmentPolyline(\n  a1: number[],\n  a2: number[],\n  points: number[][]\n): TLIntersection[] {\n  const intersections: TLIntersection[] = []\n\n  for (let i = 1; i < points.length + 1; i++) {\n    const int = intersectLineSegmentLineSegment(\n      a1,\n      a2,\n      points[i - 1],\n      points[i % points.length]\n    )\n\n    if (int) {\n      intersections.push(int)\n    }\n  }\n\n  return intersections\n}\n\n/* -------------------------------------------------- */\n/*                      Rectangle                     */\n/* -------------------------------------------------- */\n\n/**\n * Find the intersections between a rectangle and a ray.\n * @param point\n * @param size\n * @param rotation\n * @param origin\n * @param direction\n */\nexport function /*#__PURE__*/ intersectRectangleRay(\n  point: number[],\n  size: number[],\n  rotation: number,\n  origin: number[],\n  direction: number[]\n): TLIntersection[] {\n  const sideIntersections = getRectangleSides(point, size, rotation).reduce<\n    TLIntersection[]\n  >((acc, [message, [a1, a2]]) => {\n    const intersection = intersectRayLineSegment(origin, direction, a1, a2)\n\n    if (intersection) {\n      acc.push(createIntersection(message, ...intersection.points))\n    }\n\n    return acc\n  }, [])\n\n  return sideIntersections.filter((int) => int.didIntersect)\n}\n\n/**\n * Find the intersections between a rectangle and a line segment.\n * @param point\n * @param size\n * @param a1\n * @param a2\n */\nexport function /*#__PURE__*/ intersectRectangleLineSegment(\n  point: number[],\n  size: number[],\n  a1: number[],\n  a2: number[]\n): TLIntersection[] {\n  const sideIntersections = getRectangleSides(point, size).reduce<\n    TLIntersection[]\n  >((acc, [message, [b1, b2]]) => {\n    const intersection = intersectLineSegmentLineSegment(a1, a2, b1, b2)\n\n    if (intersection) {\n      acc.push(createIntersection(message, ...intersection.points))\n    }\n\n    return acc\n  }, [])\n\n  return sideIntersections.filter((int) => int.didIntersect)\n}\n\n/**\n * Find the intersections between a rectangle and a rectangle.\n * @param point1\n * @param size1\n * @param point2\n * @param size2\n */\nexport function /*#__PURE__*/ intersectRectangleRectangle(\n  point1: number[],\n  size1: number[],\n  point2: number[],\n  size2: number[]\n): TLIntersection[] {\n  const sideIntersections = getRectangleSides(point1, size1).reduce<\n    TLIntersection[]\n  >((acc, [message, [a1, a2]]) => {\n    const intersections = intersectRectangleLineSegment(point2, size2, a1, a2)\n\n    acc.push(\n      ...intersections.map((int) =>\n        createIntersection(`${message} ${int.message}`, ...int.points)\n      )\n    )\n\n    return acc\n  }, [])\n\n  return sideIntersections.filter((int) => int.didIntersect)\n}\n\n/**\n * Find the intersections between a rectangle and an arc.\n * @param point\n * @param size\n * @param center\n * @param radius\n * @param start\n * @param end\n */\nexport function /*#__PURE__*/ intersectRectangleArc(\n  point: number[],\n  size: number[],\n  center: number[],\n  radius: number,\n  start: number[],\n  end: number[]\n): TLIntersection[] {\n  const sideIntersections = getRectangleSides(point, size).reduce<\n    TLIntersection[]\n  >((acc, [message, [a1, a2]]) => {\n    const intersection = intersectArcLineSegment(\n      center,\n      radius,\n      start,\n      end,\n      a1,\n      a2\n    )\n\n    if (intersection) {\n      acc.push({ ...intersection, message })\n    }\n\n    return acc\n  }, [])\n\n  return sideIntersections.filter((int) => int.didIntersect)\n}\n\n/**\n * Find the intersections between a rectangle and a circle.\n * @param point\n * @param size\n * @param c\n * @param r\n */\nexport function /*#__PURE__*/ intersectRectangleCircle(\n  point: number[],\n  size: number[],\n  c: number[],\n  r: number\n): TLIntersection[] {\n  const sideIntersections = getRectangleSides(point, size).reduce<\n    TLIntersection[]\n  >((acc, [message, [a1, a2]]) => {\n    const intersection = intersectLineSegmentCircle(a1, a2, c, r)\n\n    if (intersection) {\n      acc.push({ ...intersection, message })\n    }\n\n    return acc\n  }, [])\n\n  return sideIntersections.filter((int) => int.didIntersect)\n}\n\n/**\n * Find the intersections between a rectangle and an ellipse.\n * @param point\n * @param size\n * @param c\n * @param rx\n * @param ry\n * @param rotation\n */\nexport function /*#__PURE__*/ intersectRectangleEllipse(\n  point: number[],\n  size: number[],\n  c: number[],\n  rx: number,\n  ry: number,\n  rotation = 0\n): TLIntersection[] {\n  const sideIntersections = getRectangleSides(point, size).reduce<\n    TLIntersection[]\n  >((acc, [message, [a1, a2]]) => {\n    const intersection = intersectLineSegmentEllipse(\n      a1,\n      a2,\n      c,\n      rx,\n      ry,\n      rotation\n    )\n\n    if (intersection) {\n      acc.push({ ...intersection, message })\n    }\n\n    return acc\n  }, [])\n\n  return sideIntersections.filter((int) => int.didIntersect)\n}\n\n/**\n * Find the intersections between a rectangle and a bounding box.\n * @param point\n * @param size\n * @param bounds\n */\nexport function /*#__PURE__*/ intersectRectangleBounds(\n  point: number[],\n  size: number[],\n  bounds: TLBounds\n): TLIntersection[] {\n  const { minX, minY, width, height } = bounds\n  return intersectRectangleRectangle(point, size, [minX, minY], [width, height])\n}\n\n/**\n * Find the intersections between a rectangle and a polyline.\n * @param point\n * @param size\n * @param points\n */\nexport function /*#__PURE__*/ intersectRectanglePolyline(\n  point: number[],\n  size: number[],\n  points: number[][]\n): TLIntersection[] {\n  const sideIntersections = getRectangleSides(point, size).reduce<\n    TLIntersection[]\n  >((acc, [message, [a1, a2]]) => {\n    const intersections = intersectLineSegmentPolyline(a1, a2, points)\n\n    if (intersections.length > 0) {\n      acc.push(\n        createIntersection(message, ...intersections.flatMap((i) => i.points))\n      )\n    }\n\n    return acc\n  }, [])\n\n  return sideIntersections.filter((int) => int.didIntersect)\n}\n\n/* -------------------------------------------------- */\n/*                         Arc                        */\n/* -------------------------------------------------- */\n\n/**\n * Find the intersections between a arc and a line segment.\n * @param center\n * @param radius\n * @param start\n * @param end\n * @param a1\n * @param a2\n */\nexport function /*#__PURE__*/ intersectArcLineSegment(\n  center: number[],\n  radius: number,\n  start: number[],\n  end: number[],\n  a1: number[],\n  a2: number[]\n): TLIntersection {\n  return intersectLineSegmentArc(a1, a2, center, radius, start, end)\n}\n\n/**\n * Find the intersections between a arc and a rectangle.\n * @param center\n * @param radius\n * @param start\n * @param end\n * @param point\n * @param size\n */\nexport function /*#__PURE__*/ intersectArcRectangle(\n  center: number[],\n  radius: number,\n  start: number[],\n  end: number[],\n  point: number[],\n  size: number[]\n): TLIntersection[] {\n  return intersectRectangleArc(point, size, center, radius, start, end)\n}\n\n/**\n * Find the intersections between a arc and a bounding box.\n * @param center\n * @param radius\n * @param start\n * @param end\n * @param bounds\n */\nexport function /*#__PURE__*/ intersectArcBounds(\n  center: number[],\n  radius: number,\n  start: number[],\n  end: number[],\n  bounds: TLBounds\n): TLIntersection[] {\n  const { minX, minY, width, height } = bounds\n  return intersectArcRectangle(\n    center,\n    radius,\n    start,\n    end,\n    [minX, minY],\n    [width, height]\n  )\n}\n\n/* -------------------------------------------------- */\n/*                       Circle                       */\n/* -------------------------------------------------- */\n\n/**\n * Find the intersections between a circle and a line segment.\n * @param c\n * @param r\n * @param a1\n * @param a2\n */\nexport function /*#__PURE__*/ intersectCircleLineSegment(\n  c: number[],\n  r: number,\n  a1: number[],\n  a2: number[]\n): TLIntersection {\n  return intersectLineSegmentCircle(a1, a2, c, r)\n}\n\n/**\n * Find the intersections between a circle and a circle.\n * @param c1\n * @param r1\n * @param c2\n * @param r2\n */\nexport function /*#__PURE__*/ intersectCircleCircle(\n  c1: number[],\n  r1: number,\n  c2: number[],\n  r2: number\n): TLIntersection {\n  let dx = c2[0] - c1[0],\n    dy = c2[1] - c1[1]\n\n  const d = Math.sqrt(dx * dx + dy * dy),\n    x = (d * d - r2 * r2 + r1 * r1) / (2 * d),\n    y = Math.sqrt(r1 * r1 - x * x)\n\n  dx /= d\n  dy /= d\n\n  return createIntersection(\n    \"intersection\",\n    [c1[0] + dx * x - dy * y, c1[1] + dy * x + dx * y],\n    [c1[0] + dx * x + dy * y, c1[1] + dy * x - dx * y]\n  )\n}\n\n/**\n * Find the intersections between a circle and a rectangle.\n * @param c\n * @param r\n * @param point\n * @param size\n */\nexport function /*#__PURE__*/ intersectCircleRectangle(\n  c: number[],\n  r: number,\n  point: number[],\n  size: number[]\n): TLIntersection[] {\n  return intersectRectangleCircle(point, size, c, r)\n}\n\n/**\n * Find the intersections between a circle and a bounding box.\n * @param c\n * @param r\n * @param bounds\n */\nexport function /*#__PURE__*/ intersectCircleBounds(\n  c: number[],\n  r: number,\n  bounds: TLBounds\n): TLIntersection[] {\n  const { minX, minY, width, height } = bounds\n  return intersectCircleRectangle(c, r, [minX, minY], [width, height])\n}\n\n/* -------------------------------------------------- */\n/*                       Ellipse                      */\n/* -------------------------------------------------- */\n\n/**\n * Find the intersections between an ellipse and a ray.\n * @param center\n * @param rx\n * @param ry\n * @param rotation\n * @param point\n * @param direction\n */\nexport function /*#__PURE__*/ intersectEllipseRay(\n  center: number[],\n  rx: number,\n  ry: number,\n  rotation: number,\n  point: number[],\n  direction: number[]\n): TLIntersection {\n  return intersectRayEllipse(point, direction, center, rx, ry, rotation)\n}\n\n/**\n * Find the intersections between an ellipse and a line segment.\n * @param center\n * @param rx\n * @param ry\n * @param rotation\n * @param a1\n * @param a2\n */\nexport function /*#__PURE__*/ intersectEllipseLineSegment(\n  center: number[],\n  rx: number,\n  ry: number,\n  rotation = 0,\n  a1: number[],\n  a2: number[]\n): TLIntersection {\n  if (rx === ry) {\n    return intersectLineSegmentCircle(a1, a2, center, rx)\n  }\n\n  return intersectLineSegmentEllipse(a1, a2, center, rx, ry, rotation)\n}\n\n/**\n * Find the intersections between an ellipse and a rectangle.\n * @param center\n * @param rx\n * @param ry\n * @param rotation\n * @param point\n * @param size\n */\nexport function /*#__PURE__*/ intersectEllipseRectangle(\n  center: number[],\n  rx: number,\n  ry: number,\n  rotation = 0,\n  point: number[],\n  size: number[]\n): TLIntersection[] {\n  if (rx === ry) {\n    return intersectRectangleCircle(point, size, center, rx)\n  }\n\n  return intersectRectangleEllipse(point, size, center, rx, ry, rotation)\n}\n\n/**\n * Find the intersections between an ellipse and an ellipse.\n * Adapted from https://gist.github.com/drawable/92792f59b6ff8869d8b1\n * @param _c1\n * @param _rx1\n * @param _ry1\n * @param _r1\n * @param _c2\n * @param _rx2\n * @param _ry2\n * @param _r2\n */\nexport function /*#__PURE__*/ intersectEllipseEllipse(\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  _c1: number[],\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  _rx1: number,\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  _ry1: number,\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  _r1: number,\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  _c2: number[],\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  _rx2: number,\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  _ry2: number,\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  _r2: number\n): TLIntersection {\n  // TODO\n  return createIntersection(\"no intersection\")\n}\n\n/**\n * Find the intersections between an ellipse and a circle.\n * @param c\n * @param rx\n * @param ry\n * @param rotation\n * @param c2\n * @param r2\n */\nexport function /*#__PURE__*/ intersectEllipseCircle(\n  c: number[],\n  rx: number,\n  ry: number,\n  rotation: number,\n  c2: number[],\n  r2: number\n): TLIntersection {\n  return intersectEllipseEllipse(c, rx, ry, rotation, c2, r2, r2, 0)\n}\n\n/**\n * Find the intersections between an ellipse and a bounding box.\n * @param c\n * @param rx\n * @param ry\n * @param rotation\n * @param bounds\n */\nexport function /*#__PURE__*/ intersectEllipseBounds(\n  c: number[],\n  rx: number,\n  ry: number,\n  rotation: number,\n  bounds: TLBounds\n): TLIntersection[] {\n  const { minX, minY, width, height } = bounds\n  return intersectEllipseRectangle(\n    c,\n    rx,\n    ry,\n    rotation,\n    [minX, minY],\n    [width, height]\n  )\n}\n\n/**\n * Find the intersections between a bounding box and a ray.\n * @param bounds\n * @param origin\n * @param direction\n */\nexport function /*#__PURE__*/ intersectBoundsRay(\n  bounds: TLBounds,\n  origin: number[],\n  direction: number[]\n): TLIntersection[] {\n  const { minX, minY, width, height } = bounds\n  return intersectRayRectangle(origin, direction, [minX, minY], [width, height])\n}\n\n/**\n * Find the intersections between a bounding box and a line segment.\n * @param bounds\n * @param a1\n * @param a2\n */\nexport function /*#__PURE__*/ intersectBoundsLineSegment(\n  bounds: TLBounds,\n  a1: number[],\n  a2: number[]\n): TLIntersection[] {\n  const { minX, minY, width, height } = bounds\n  return intersectLineSegmentRectangle(a1, a2, [minX, minY], [width, height])\n}\n\n/**\n * Find the intersections between a bounding box and a rectangle.\n * @param bounds\n * @param point\n * @param size\n */\nexport function /*#__PURE__*/ intersectBoundsRectangle(\n  bounds: TLBounds,\n  point: number[],\n  size: number[]\n): TLIntersection[] {\n  const { minX, minY, width, height } = bounds\n  return intersectRectangleRectangle(point, size, [minX, minY], [width, height])\n}\n\n/**\n * Find the intersections between a bounding box and a bounding box.\n * @param bounds1\n * @param bounds2\n */\nexport function /*#__PURE__*/ intersectBoundsBounds(\n  bounds1: TLBounds,\n  bounds2: TLBounds\n): TLIntersection[] {\n  return intersectRectangleRectangle(\n    [bounds1.minX, bounds1.minY],\n    [bounds1.width, bounds1.height],\n    [bounds2.minX, bounds2.minY],\n    [bounds2.width, bounds2.height]\n  )\n}\n\n/**\n * Find the intersections between a bounding box and an arc.\n * @param bounds\n * @param center\n * @param radius\n * @param start\n * @param end\n */\nexport function /*#__PURE__*/ intersectBoundsArc(\n  bounds: TLBounds,\n  center: number[],\n  radius: number,\n  start: number[],\n  end: number[]\n): TLIntersection[] {\n  const { minX, minY, width, height } = bounds\n  return intersectArcRectangle(\n    center,\n    radius,\n    start,\n    end,\n    [minX, minY],\n    [width, height]\n  )\n}\n\n/**\n * Find the intersections between a bounding box and a circle.\n * @param bounds\n * @param c\n * @param r\n */\nexport function /*#__PURE__*/ intersectBoundsCircle(\n  bounds: TLBounds,\n  c: number[],\n  r: number\n): TLIntersection[] {\n  const { minX, minY, width, height } = bounds\n  return intersectCircleRectangle(c, r, [minX, minY], [width, height])\n}\n\n/**\n * Find the intersections between a bounding box and an ellipse.\n * @param bounds\n * @param c\n * @param rx\n * @param ry\n * @param rotation\n */\nexport function /*#__PURE__*/ intersectBoundsEllipse(\n  bounds: TLBounds,\n  c: number[],\n  rx: number,\n  ry: number,\n  rotation = 0\n): TLIntersection[] {\n  const { minX, minY, width, height } = bounds\n  return intersectEllipseRectangle(\n    c,\n    rx,\n    ry,\n    rotation,\n    [minX, minY],\n    [width, height]\n  )\n}\n\n/**\n * Find the intersections between a bounding box and a polyline.\n * @param bounds\n * @param points\n */\nexport function /*#__PURE__*/ intersectBoundsPolyline(\n  bounds: TLBounds,\n  points: number[][]\n): TLIntersection[] {\n  return intersectPolylineBounds(points, bounds)\n}\n\n/* -------------------------------------------------- */\n/*                      Polyline                      */\n/* -------------------------------------------------- */\n\n/**\n * Find the intersections between a polyline and a line segment.\n * @param points\n * @param a1\n * @param a2\n */\nexport function /*#__PURE__*/ intersectPolylineLineSegment(\n  points: number[][],\n  a1: number[],\n  a2: number[]\n): TLIntersection[] {\n  return intersectLineSegmentPolyline(a1, a2, points)\n}\n\n/**\n * Find the intersections between a polyline and a rectangle.\n * @param points\n * @param point\n * @param size\n */\nexport function /*#__PURE__*/ intersectPolylineRectangle(\n  points: number[][],\n  point: number[],\n  size: number[]\n): TLIntersection[] {\n  return intersectRectanglePolyline(point, size, points)\n}\n\n/**\n * Find the intersections between a polyline and a bounding box.\n * @param points\n * @param bounds\n */\nexport function /*#__PURE__*/ intersectPolylineBounds(\n  points: number[][],\n  bounds: TLBounds\n): TLIntersection[] {\n  return intersectRectanglePolyline(\n    [bounds.minX, bounds.minY],\n    [bounds.width, bounds.height],\n    points\n  )\n}\n"],"names":[],"version":3,"file":"types.d.ts.map"}